#pragma kernel CSMain

RWTexture2D<float2> velocity;
RWTexture2D<float4> terrain;


float sedimentCapConst;
float l;

float size;

float computeAngle(uint3 id)
{
	uint2 gl = uint2(id.x - 1, id.y);
	gl.x = clamp(gl.x, 0, size - 1);

	uint2 gr = uint2(id.x + 1, id.y);
	gr.x = clamp(gr.x, 0, size - 1);

	float h = terrain[uint2(id.x, id.y)].r;//heights for center, left and right cells
	float hl = terrain[gl].r;
	float hr = terrain[gr].r;
	float dl = h - hl;//diffrence between center and left
	float dr = h - hr;//diffrence between center and right

	if (hr == 0)
	{
		if (hl != 0)
		{
			return degrees(atan(dl / l));
		}
		else
		{
			return 0;
		}
	}
	else if (hl != 0)
	{
		if (dl > dr)
		{
			return degrees(atan(dl / l));
		}
		else
		{
			return degrees(atan(dr / l));
		}
	}
	else
	{
		return degrees(atan(dr / l));
	}

	return 0;
}

void dissolveSediment(uint3 id, float c)
{
	if (c > terrain[id.xy].b)
	{
		terrain[id.xy] -= float4(sedimentCapConst * (c - terrain[id.xy].b), 0, 0, 0);
		terrain[id.xy] += float4(0, 0, sedimentCapConst * (c - terrain[id.xy].b), 0);
	}
	else if (c <= terrain[id.xy].b)
	{
		terrain[id.xy] += float4(sedimentCapConst * (terrain[id.xy].b - c), 0, 0, 0);
		terrain[id.xy] -= float4(0, 0, sedimentCapConst * (terrain[id.xy].b - c), 0);
	}
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	terrain[id.xy] = float4(terrain[id.xy].x, terrain[id.xy].y, terrain[id.xy].w, terrain[id.xy].w);
	float a = computeAngle(id);
	float c = sedimentCapConst * sin(a) * sqrt((velocity[id.xy].x * velocity[id.xy].x) + (velocity[id.xy].y * velocity[id.xy].y));
	dissolveSediment(id, c);
	terrain[id.xy] = float4(terrain[id.xy].x, terrain[id.xy].y, terrain[id.xy].z, terrain[id.xy].z);
}
