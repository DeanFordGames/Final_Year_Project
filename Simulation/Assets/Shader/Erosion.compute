#pragma kernel CSMain

RWTexture2D<float2> velocity;
RWTexture2D<float4> terrain;


float sedimentCapConst;
float l;



float computeAngle(uint3 id)
{
	float h = terrain[uint2(id.x, id.y)].r;//heights for center, left and right cells
	float hl = terrain[uint2(id.x - 1, id.y)].r;
	float hr = terrain[uint2(id.x + 1, id.y)].r;
	float dl = h - hl;//diffrence between center and left
	float dr = h - hr;//diffrence between center and right

	if (hr == 0)
	{
		if (hl != 0)
		{
			return atan(dl / l);
		}
		else
		{
			return 0;
		}
	}
	else if (hl != 0)
	{
		if (dl > dr)
		{
			return atan(dl / l);
		}
		else
		{
			return atan(dr / l);
		}
	}
	else
	{
		return atan(dr / l);
	}

	return 0;
}

void dissolveSediment(uint3 id, float c)
{
	if (c > terrain[id.xy].b)
	{
		terrain[id.xy] -= float4(sedimentCapConst * (c - terrain[id.xy].b), 0, 0, 0);
		terrain[id.xy] += float4(0, 0, sedimentCapConst * (c - terrain[id.xy].b), 0);
	}
	else if (c <= terrain[id.xy].b)
	{
		terrain[id.xy] += float4(sedimentCapConst * (terrain[id.xy].b - c), 0, 0, 0);
		terrain[id.xy] -= float4(0, 0, sedimentCapConst * (terrain[id.xy].b - c), 0);
	}
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float a = computeAngle(id);
	float c = sedimentCapConst * sin(a) * sqrt(velocity[id.xy].x * velocity[id.xy].y);
	dissolveSediment(id, c);
	terrain[id.xy] = float4(terrain[id.xy].r, terrain[id.xy].g, terrain[id.xy].b, terrain[id.xy].b);
}
