// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//flux values: x = left, y = right, z = top, w = bottom
RWTexture2D<float4> flux;
//r = terrain | g = water
RWTexture2D<float4> terrain;

//scalar so that flux doesnt make water volume negative
float k;
float dTime;
//cross sectional value for area of pipe
float a;
//gravity
float g;
//length of pipe
float l;
//current elevation scale
float scale;

//calculate height difference
float4 computeHeightDiff(uint3 id)
{
	float2 t = float2(terrain[id.xy].r, terrain[id.xy].g) * scale;
	float2 tl = float2(terrain[uint2(id.x - 1, id.y)].r, terrain[uint2(id.x - 1, id.y)].g) * scale;
	float2 tr = float2(terrain[uint2(id.x + 1, id.y)].r, terrain[uint2(id.x + 1, id.y)].g) * scale;
	float2 tt = float2(terrain[uint2(id.x, id.y + 1)].r, terrain[uint2(id.x, id.y + 1)].g) * scale;
	float2 tb = float2(terrain[uint2(id.x, id.y - 1)].r, terrain[uint2(id.x, id.y - 1)].g) * scale;

	float hl = t.y + t.x - tl.y - tl.x;
	float hr = t.y + t.x - tr.y - tr.x;
	float ht = t.y + t.x - tt.y - tt.x;
	float hb = t.y + t.x - tb.y - tb.x;
	return float4(hl, hr, ht, hb);
}

//calculate flux
float4 computeFlux(uint3 id, float4 hd)
{
	float4 zero = float4(0.0f, 0.0f, 0.0f, 0.0f);
	return max(zero, (flux[id.xy] * scale) + dTime * a * ((g * hd) / l));
}

//calculate scalar
float computeScalar(uint3 id, float4 f)
{
	float fa = (f.x + f.y + f.z + f.w) * dTime;
	float s = ((terrain[id.xy].g * scale) * l) / fa;
	return min(1, s);
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4 hd = computeHeightDiff(id);
	float4 f = computeFlux(id, hd);
	float k = computeScalar(id, f);
	flux[id.xy] = (f * k) / scale;
}
